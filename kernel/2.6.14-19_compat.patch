diff --git a/iscsi_compat.h b/iscsi_compat.h
new file mode 100644
index 0000000..965157a
--- /dev/null
+++ b/iscsi_compat.h
@@ -0,0 +1,192 @@
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+
+#ifndef ISCSI_COMPAT
+#define ISCSI_COMPAT
+
+#ifndef SCAN_WILD_CARD
+#define SCAN_WILD_CARD  ~0
+#endif
+
+#ifndef NIPQUAD_FMT
+#define NIPQUAD_FMT "%u.%u.%u.%u"
+#endif
+
+#ifndef NIP6_FMT
+#define NIP6_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+#endif
+
+#ifndef DEFINE_MUTEX
+
+/* mutex changes from 2.6.16-rc1 and up */
+#define DEFINE_MUTEX DECLARE_MUTEX
+#define mutex_lock down
+#define mutex_unlock up
+#define mutex semaphore
+#define mutex_init init_MUTEX
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
+
+void int_to_scsilun(unsigned int lun, struct scsi_lun *scsilun)
+{
+	int i;
+
+	memset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));
+
+	for (i = 0; i < sizeof(lun); i += 2) {
+		scsilun->scsi_lun[i] = (lun >> 8) & 0xFF;
+		scsilun->scsi_lun[i+1] = lun & 0xFF;
+		lun = lun >> 16;
+	}
+}
+
+#define __nlmsg_put(skb, daemon_pid, seq, type, len, flags) \
+	__nlmsg_put(skb, daemon_pid, 0, 0, len)
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13)
+
+#define netlink_kernel_create(net, uint, groups, input, cb_mutex, mod) \
+	netlink_kernel_create(uint, input)
+
+#define gfp_t unsigned
+
+void *kzalloc(size_t size, gfp_t flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+}
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+
+#include "linux/crypto.h"
+
+#define CRYPTO_ALG_ASYNC		0x00000080
+struct hash_desc
+{
+	struct crypto_tfm *tfm;
+	u32 flags;
+};
+
+static inline int crypto_hash_init(struct hash_desc *desc)
+{
+	crypto_digest_init(desc->tfm);
+	return 0;
+}
+
+static inline int crypto_hash_digest(struct hash_desc *desc,
+				     struct scatterlist *sg,
+				     unsigned int nbytes, u8 *out)
+{
+	crypto_digest_digest(desc->tfm, sg, 1, out);
+	return nbytes;
+}
+
+static inline int crypto_hash_update(struct hash_desc *desc,
+				     struct scatterlist *sg,
+				     unsigned int nbytes)
+{
+	crypto_digest_update(desc->tfm, sg, 1);
+	return nbytes;
+}
+
+static inline int crypto_hash_final(struct hash_desc *desc, u8 *out)
+{
+	crypto_digest_final(desc->tfm, out);
+	return 0;
+}
+
+static inline struct crypto_tfm *crypto_alloc_hash(const char *alg_name,
+						    u32 type, u32 mask)
+{
+	struct crypto_tfm *ret = crypto_alloc_tfm(alg_name ,type);
+	return ret ? ret : ERR_PTR(-ENOMEM);
+}
+
+static inline void crypto_free_hash(struct crypto_tfm *tfm)
+{
+	crypto_free_tfm(tfm);
+}
+
+int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+			int *addrlen)
+{
+	return sock->ops->getname(sock, addr, addrlen, 0);
+}
+
+int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+			int *addrlen)
+{
+	return sock->ops->getname(sock, addr, addrlen, 1);
+}
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+
+static inline int is_power_of_2(unsigned long n)
+{
+	return (n != 0 && ((n & (n - 1)) == 0));
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,21)
+#define netlink_kernel_create(net, uint, groups, input, cb_mutex, mod) \
+	netlink_kernel_create(uint, groups, input, mod)
+
+#endif
+
+static inline struct scatterlist *sg_next(struct scatterlist *sg)
+{
+	if (!sg) {
+		BUG();
+		return NULL;
+	}
+	return sg + 1;
+}
+
+#define for_each_sg(sglist, sg, nr, __i)        \
+	for (__i = 0, sg = (sglist); __i < (nr); __i++, sg = sg_next(sg))
+
+#define sg_page(_sg) _sg->page
+
+static inline void sg_set_page(struct scatterlist *sg, struct page *page,
+				unsigned int len, unsigned int offset)
+{
+	sg->page = page;
+	sg->offset = offset;
+	sg->length = len;
+}
+
+static inline void sg_init_table(struct scatterlist *sgl, unsigned int nents)
+{
+	memset(sgl, 0, sizeof(*sgl) * nents);
+}
+
+#define scsi_sg_count(cmd) ((cmd)->use_sg)
+#define scsi_sglist(cmd) ((struct scatterlist *)(cmd)->request_buffer)
+#define scsi_bufflen(cmd) ((cmd)->request_bufflen)
+
+static inline void scsi_set_resid(struct scsi_cmnd *cmd, int resid)
+{
+	cmd->resid = resid;
+}
+
+static inline int scsi_get_resid(struct scsi_cmnd *cmd)
+{
+	return cmd->resid;
+}
+
+static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
+{
+	return (struct nlmsghdr *)skb->data;
+}
+
+#endif
diff --git a/iscsi_tcp.c b/iscsi_tcp.c
index ce1fdf1..385d098 100644
--- a/iscsi_tcp.c
+++ b/iscsi_tcp.c
@@ -43,6 +43,7 @@
 #include "scsi_transport_iscsi.h"
 
 #include "iscsi_tcp.h"
+#include "iscsi_compat.h"
 
 MODULE_AUTHOR("Dmitry Yusupov <dmitry_yus@yahoo.com>, "
 	      "Alex Aizman <itn780@yahoo.com>");
@@ -422,6 +423,17 @@ iscsi_segment_seek_sg(struct iscsi_segment *segment,
 
 	debug_scsi("iscsi_segment_seek_sg offset %u size %llu\n",
 		  offset, size);
+
+	/*
+	 * older kernels could send use_sg=0 for commands like sgio
+	 * or scsi-ml commands.
+	 */
+	if (!sg_count) {
+		iscsi_segment_init_linear(segment, (void *)sg_list + offset,
+					  size, done, hash);
+		return 0;
+	}
+
 	__iscsi_segment_init(segment, size, done, hash);
 	for_each_sg(sg_list, sg, sg_count, i) {
 		debug_scsi("sg %d, len %u offset %u\n", i, sg->length,
@@ -1933,7 +1945,9 @@ static struct scsi_host_template iscsi_sht = {
 	.eh_device_reset_handler= iscsi_eh_device_reset,
 	.eh_host_reset_handler	= iscsi_eh_host_reset,
 	.use_clustering         = DISABLE_CLUSTERING,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	.use_sg_chaining	= ENABLE_SG_CHAINING,
+#endif
 	.slave_configure        = iscsi_tcp_slave_configure,
 	.proc_name		= "iscsi_tcp",
 	.this_id		= -1,
diff --git a/iscsi_tcp.h b/iscsi_tcp.h
index 950d75f..662ddab 100644
--- a/iscsi_tcp.h
+++ b/iscsi_tcp.h
@@ -24,6 +24,7 @@
 
 #include "libiscsi.h"
 
+#include "iscsi_compat.h"
 struct crypto_hash;
 struct socket;
 struct iscsi_tcp_conn;
diff --git a/ibiscsi.c b/libiscsi.c
index 0c64d82..e88021f 100644
--- a/libiscsi.c
+++ b/libiscsi.c
@@ -24,7 +24,10 @@
 #include <linux/types.h>
 #include <linux/kfifo.h>
 #include <linux/delay.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
 #include <linux/log2.h>
+#endif
 #include <asm/unaligned.h>
 #include <net/tcp.h>
 #include <scsi/scsi_cmnd.h>
@@ -974,10 +977,9 @@ again:
 	return rc;
 }
 
-static void iscsi_xmitworker(struct work_struct *work)
+static void iscsi_xmitworker(void *data)
 {
-	struct iscsi_conn *conn =
-		container_of(work, struct iscsi_conn, xmitwork);
+	struct iscsi_conn *conn = data;
 	int rc;
 	/*
 	 * serialize Xmit worker on a per-connection basis.
@@ -1737,7 +1739,9 @@ iscsi_session_setup(struct iscsi_transport *iscsit,
 	shost->max_cmd_len = iscsit->max_cmd_len;
 	shost->transportt = scsit;
 	shost->transportt->create_work_queue = 1;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
 	shost->transportt->eh_timed_out = iscsi_eh_cmd_timed_out;
+#endif
 	*hostno = shost->host_no;
 
 	session = iscsi_hostdata(shost->hostdata);
@@ -1887,7 +1891,7 @@ iscsi_conn_setup(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	INIT_LIST_HEAD(&conn->mgmtqueue);
 	INIT_LIST_HEAD(&conn->xmitqueue);
 	INIT_LIST_HEAD(&conn->requeue);
-	INIT_WORK(&conn->xmitwork, iscsi_xmitworker);
+	INIT_WORK(&conn->xmitwork, iscsi_xmitworker, conn);
 
 	/* allocate login_mtask used for the login/text sequences */
 	spin_lock_bh(&session->lock);
diff --git a/libiscsi.h b/libiscsi.h
index 72f6fc6..d9161aa 100644
--- a/libiscsi.h
+++ b/libiscsi.h
@@ -24,12 +24,14 @@
 #define LIBISCSI_H
 
 #include <linux/types.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
 #include <linux/mutex.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
+#endif
 #include "iscsi_proto.h"
 #include "iscsi_if.h"
 
+#include "iscsi_compat.h"
+
 struct scsi_transport_template;
 struct scsi_device;
 struct Scsi_Host;
diff --git a/scsi_transport_iscsi.c b/scsi_transport_iscsi.c
index 4686f3a..075473b 100644
--- a/scsi_transport_iscsi.c
+++ b/scsi_transport_iscsi.c
@@ -21,7 +21,10 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 #include <linux/module.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
 #include <linux/mutex.h>
+#endif
 #include <net/tcp.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
@@ -29,6 +32,7 @@
 #include <scsi/scsi_transport.h>
 #include "scsi_transport_iscsi.h"
 #include "iscsi_if.h"
+#include "iscsi_compat.h"
 
 #define ISCSI_SESSION_ATTRS 19
 #define ISCSI_CONN_ATTRS 13
@@ -322,10 +326,9 @@ static int iscsi_user_scan(struct Scsi_Host *shost, uint channel,
 	return 0;
 }
 
-static void iscsi_scan_session(struct work_struct *work)
+static void iscsi_scan_session(void *data)
 {
-	struct iscsi_cls_session *session =
-			container_of(work, struct iscsi_cls_session, scan_work);
+	struct iscsi_cls_session *session = data;
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_host *ihost = shost->shost_data;
 	unsigned long flags;
@@ -343,11 +346,9 @@ done:
 	atomic_dec(&ihost->nr_scans);
 }
 
-static void session_recovery_timedout(struct work_struct *work)
+static void session_recovery_timedout(void *data)
 {
-	struct iscsi_cls_session *session =
-		container_of(work, struct iscsi_cls_session,
-			     recovery_work.work);
+	struct iscsi_cls_session *session = data;
 	unsigned long flags;
 
	iscsi_cls_session_printk(KERN_INFO, session,
@@ -395,10 +396,12 @@ void iscsi_unblock_session(struct iscsi_cls_session *session)
 	 * the async scanning code (drivers like iscsi_tcp do login and
 	 * scanning from userspace).
 	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
 	if (shost->hostt->scan_finished) {
 		if (queue_work(ihost->scan_workq, &session->scan_work))
 			atomic_inc(&ihost->nr_scans);
 	}
+#endif
 }
 EXPORT_SYMBOL_GPL(iscsi_unblock_session);
 
@@ -416,11 +419,9 @@ void iscsi_block_session(struct iscsi_cls_session *session)
 }
 EXPORT_SYMBOL_GPL(iscsi_block_session);
 
-static void __iscsi_unbind_session(struct work_struct *work)
+static void __iscsi_unbind_session(void *data)
 {
-	struct iscsi_cls_session *session =
-			container_of(work, struct iscsi_cls_session,
-				     unbind_work);
+	struct iscsi_cls_session *session = data;
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_host *ihost = shost->shost_data;
 
@@ -459,11 +460,11 @@ iscsi_alloc_session(struct Scsi_Host *shost,
 	session->transport = transport;
 	session->recovery_tmo = 120;
 	session->state = ISCSI_SESSION_FREE;
-	INIT_DELAYED_WORK(&session->recovery_work, session_recovery_timedout);
+	INIT_WORK(&session->recovery_work, session_recovery_timedout, session);
 	INIT_LIST_HEAD(&session->host_list);
 	INIT_LIST_HEAD(&session->sess_list);
-	INIT_WORK(&session->unbind_work, __iscsi_unbind_session);
-	INIT_WORK(&session->scan_work, iscsi_scan_session);
+	INIT_WORK(&session->unbind_work, __iscsi_unbind_session, session);
+	INIT_WORK(&session->scan_work, iscsi_scan_session, session);
 	spin_lock_init(&session->lock);
 
 	/* this is released in the dev's release function */
@@ -1269,45 +1270,56 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
  * Malformed skbs with wrong lengths or invalid creds are not processed.
  */
 static void
-iscsi_if_rx(struct sk_buff *skb)
+iscsi_if_rx(struct sock *sk, int len)
 {
+	struct sk_buff *skb;
+
 	mutex_lock(&rx_queue_mutex);
-	while (skb->len >= NLMSG_SPACE(0)) {
-		int err;
-		uint32_t rlen;
-		struct nlmsghdr	*nlh;
-		struct iscsi_uevent *ev;
-
-		nlh = nlmsg_hdr(skb);
-		if (nlh->nlmsg_len < sizeof(*nlh) ||
-		    skb->len < nlh->nlmsg_len) {
-			break;
+	while ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {
+		if (NETLINK_CREDS(skb)->uid) {
+			skb_pull(skb, skb->len);
+			goto free_skb;
 		}
 
-		ev = NLMSG_DATA(nlh);
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
+		while (skb->len >= NLMSG_SPACE(0)) {
+			int err;
+			uint32_t rlen;
+			struct nlmsghdr	*nlh;
+			struct iscsi_uevent *ev;
 
-		err = iscsi_if_recv_msg(skb, nlh);
-		if (err) {
-			ev->type = ISCSI_KEVENT_IF_ERROR;
-			ev->iferror = err;
-		}
-		do {
-			/*
-			 * special case for GET_STATS:
-			 * on success - sending reply and stats from
-			 * inside of if_recv_msg(),
-			 * on error - fall through.
-			 */
-			if (ev->type == ISCSI_UEVENT_GET_STATS && !err)
+			nlh = nlmsg_hdr(skb);
+			if (nlh->nlmsg_len < sizeof(*nlh) ||
+			    skb->len < nlh->nlmsg_len) {
 				break;
-			err = iscsi_if_send_reply(
-				NETLINK_CREDS(skb)->pid, nlh->nlmsg_seq,
-				nlh->nlmsg_type, 0, 0, ev, sizeof(*ev));
-		} while (err < 0 && err != -ECONNREFUSED);
-		skb_pull(skb, rlen);
+			}
+
+			ev = NLMSG_DATA(nlh);
+			rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+			if (rlen > skb->len)
+				rlen = skb->len;
+
+			err = iscsi_if_recv_msg(skb, nlh);
+			if (err) {
+				ev->type = ISCSI_KEVENT_IF_ERROR;
+				ev->iferror = err;
+			}
+			do {
+				/*
+				 * special case for GET_STATS:
+				 * on success - sending reply and stats from
+				 * inside of if_recv_msg(),
+				 * on error - fall through.
+				 */
+				if (ev->type == ISCSI_UEVENT_GET_STATS && !err)
+					break;
+				err = iscsi_if_send_reply(
+					NETLINK_CREDS(skb)->pid, nlh->nlmsg_seq,
+					nlh->nlmsg_type, 0, 0, ev, sizeof(*ev));
+			} while (err < 0 && err != -ECONNREFUSED);
+			skb_pull(skb, rlen);
+		}
+free_skb:
+		kfree_skb(skb);
 	}
 	mutex_unlock(&rx_queue_mutex);
 }
@@ -1551,7 +1563,10 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	INIT_LIST_HEAD(&priv->list);
 	priv->daemon_pid = -1;
 	priv->iscsi_transport = tt;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
 	priv->t.user_scan = iscsi_user_scan;
+#endif
 
 	priv->cdev.class = &iscsi_transport_class;
 	snprintf(priv->cdev.class_id, BUS_ID_SIZE, "%s", tt->name);
diff --git a/scsi_transport_iscsi.h b/scsi_transport_iscsi.h
index 5cf5f54..eb1b1c4 100644
--- a/scsi_transport_iscsi.h
+++ b/scsi_transport_iscsi.h
@@ -25,8 +25,12 @@
 
 #include <linux/device.h>
 #include <linux/list.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
 #include <linux/mutex.h>
+#endif
 #include "iscsi_if.h"
+#include "iscsi_compat.h"
 
 struct scsi_transport_template;
 struct iscsi_transport;
@@ -182,7 +186,7 @@ struct iscsi_cls_session {
 
 	/* recovery fields */
 	int recovery_tmo;
-	struct delayed_work recovery_work;
+	struct work_struct recovery_work;
 
 	int target_id;
 
-- 
1.5.1.2

