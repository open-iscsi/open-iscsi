diff --git a/iscsi_tcp.c b/iscsi_tcp.c
index 2a401b9..13636d4 100644
--- a/iscsi_tcp.c
+++ b/iscsi_tcp.c
@@ -43,6 +43,7 @@
 #include <scsi/scsi.h>
 #include "scsi_transport_iscsi.h"
 
+#include "open_iscsi_compat.h"
 #include "iscsi_tcp.h"
 
 MODULE_AUTHOR("Mike Christie <michaelc@cs.wisc.edu>, "
@@ -480,10 +481,9 @@ static int iscsi_sw_tcp_pdu_init(struct iscsi_task *task,
 	if (!task->sc)
 		iscsi_sw_tcp_send_linear_data_prep(conn, task->data, count);
 	else {
-		struct scsi_data_buffer *sdb = scsi_out(task->sc);
 
-		err = iscsi_sw_tcp_send_data_prep(conn, sdb->table.sgl,
-						  sdb->table.nents, offset,
+		err = iscsi_sw_tcp_send_data_prep(conn, scsi_sglist(task->sc),
+						  scsi_sg_count(task->sc), offset,
 						  count);
 	}
 
@@ -860,12 +860,6 @@ static void iscsi_sw_tcp_session_destroy(struct iscsi_cls_session *cls_session)
 	iscsi_host_free(shost);
 }
 
-static int iscsi_sw_tcp_slave_alloc(struct scsi_device *sdev)
-{
-	set_bit(QUEUE_FLAG_BIDI, &sdev->request_queue->queue_flags);
-	return 0;
-}
-
 static int iscsi_sw_tcp_slave_configure(struct scsi_device *sdev)
 {
 	blk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_ANY);
@@ -883,10 +877,9 @@ static struct scsi_host_template iscsi_sw_tcp_sht = {
 	.max_sectors		= 0xFFFF,
 	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
 	.eh_abort_handler       = iscsi_eh_abort,
+	.eh_host_reset_handler	= iscsi_eh_recover_target,
 	.eh_device_reset_handler= iscsi_eh_device_reset,
-	.eh_target_reset_handler = iscsi_eh_recover_target,
 	.use_clustering         = DISABLE_CLUSTERING,
-	.slave_alloc            = iscsi_sw_tcp_slave_alloc,
 	.slave_configure        = iscsi_sw_tcp_slave_configure,
 	.target_alloc		= iscsi_target_alloc,
 	.proc_name		= "iscsi_tcp",
diff --git a/libiscsi.c b/libiscsi.c
index 59e3a5f..ee9716e 100644
--- a/libiscsi.c
+++ b/libiscsi.c
@@ -24,7 +24,10 @@
 #include <linux/types.h>
 #include <linux/kfifo.h>
 #include <linux/delay.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
 #include <linux/log2.h>
+#endif
 #include <linux/slab.h>
 #include <asm/unaligned.h>
 #include <net/tcp.h>
@@ -39,6 +42,8 @@
 #include "scsi_transport_iscsi.h"
 #include "libiscsi.h"
 
+#include "open_iscsi_compat.h"
+
 static int iscsi_dbg_lib_conn;
 module_param_named(debug_libiscsi_conn, iscsi_dbg_lib_conn, int,
 		   S_IRUGO | S_IWUSR);
@@ -256,7 +261,7 @@ static int iscsi_prep_bidi_ahs(struct iscsi_task *task)
 						  sizeof(rlen_ahdr->reserved));
 	rlen_ahdr->ahstype = ISCSI_AHSTYPE_RLENGTH;
 	rlen_ahdr->reserved = 0;
-	rlen_ahdr->read_length = cpu_to_be32(scsi_in(sc)->length);
+	rlen_ahdr->read_length = cpu_to_be32(scsi_bufflen(sc));
 
 	ISCSI_DBG_SESSION(task->conn->session,
 			  "bidi-in rlen_ahdr->read_length(%d) "
@@ -411,7 +416,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 			return rc;
 	}
 	if (sc->sc_data_direction == DMA_TO_DEVICE) {
-		unsigned out_len = scsi_out(sc)->length;
+		unsigned out_len = scsi_bufflen(sc);
 		struct iscsi_r2t_info *r2t = &task->unsol_r2t;
 
 		hdr->data_length = cpu_to_be32(out_len);
@@ -457,7 +462,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	} else {
 		hdr->flags |= ISCSI_FLAG_CMD_FINAL;
 		zero_data(hdr->dlength);
-		hdr->data_length = cpu_to_be32(scsi_in(sc)->length);
+		hdr->data_length = cpu_to_be32(scsi_bufflen(sc));
 
 		if (sc->sc_data_direction == DMA_FROM_DEVICE)
 			hdr->flags |= ISCSI_FLAG_CMD_READ;
@@ -486,7 +491,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 			  sc->sc_data_direction == DMA_TO_DEVICE ?
 			  "write" : "read", conn->id, sc, sc->cmnd[0],
 			  task->itt, scsi_bufflen(sc),
-			  scsi_bidi_cmnd(sc) ? scsi_in(sc)->length : 0,
+			  scsi_bidi_cmnd(sc) ? scsi_bufflen(sc) : 0,
 			  session->cmdsn,
 			  session->max_cmdsn - session->exp_cmdsn + 1);
 	return 0;
@@ -518,7 +523,7 @@ static void iscsi_free_task(struct iscsi_task *task)
 	if (conn->login_task == task)
 		return;
 
-	kfifo_in(&session->cmdpool.queue, (void*)&task, sizeof(void*));
+	__kfifo_put(session->cmdpool.queue, (void*)&task, sizeof(void*));
 
 	if (sc) {
 		task->sc = NULL;
@@ -648,12 +653,7 @@ static void fail_scsi_task(struct iscsi_task *task, int err)
 		state = ISCSI_TASK_ABRT_TMF;
 
 	sc->result = err << 16;
-	if (!scsi_bidi_cmnd(sc))
-		scsi_set_resid(sc, scsi_bufflen(sc));
-	else {
-		scsi_out(sc)->resid = scsi_out(sc)->length;
-		scsi_in(sc)->resid = scsi_in(sc)->length;
-	}
+	scsi_set_resid(sc, scsi_bufflen(sc));
 
 	iscsi_complete_task(task, state);
 }
@@ -738,7 +738,7 @@ __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		BUG_ON(conn->c_stage == ISCSI_CONN_INITIAL_STAGE);
 		BUG_ON(conn->c_stage == ISCSI_CONN_STOPPED);
 
-		if (!kfifo_out(&session->cmdpool.queue,
+		if (!__kfifo_get(session->cmdpool.queue,
 				 (void*)&task, sizeof(void*)))
 			return NULL;
 	}
@@ -853,7 +853,7 @@ invalid_datalen:
 			goto out;
 		}
 
-		senselen = get_unaligned_be16(data);
+		senselen = be16_to_cpu(get_unaligned((__be16 *) data));
 		if (datalen < senselen)
 			goto invalid_datalen;
 
@@ -870,8 +870,8 @@ invalid_datalen:
 
 		if (scsi_bidi_cmnd(sc) && res_count > 0 &&
 				(rhdr->flags & ISCSI_FLAG_CMD_BIDI_OVERFLOW ||
-				 res_count <= scsi_in(sc)->length))
-			scsi_in(sc)->resid = res_count;
+				 res_count <= scsi_bufflen(sc)))
+			scsi_set_resid(sc, res_count);
 		else
 			sc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;
 	}
@@ -920,8 +920,8 @@ iscsi_data_in_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 
 		if (res_count > 0 &&
 		    (rhdr->flags & ISCSI_FLAG_CMD_OVERFLOW ||
-		     res_count <= scsi_in(sc)->length))
-			scsi_in(sc)->resid = res_count;
+		     res_count <= scsi_bufflen(sc)))
+			scsi_set_resid(sc, res_count);
 		else
 			sc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;
 	}
@@ -1568,7 +1568,7 @@ static inline struct iscsi_task *iscsi_alloc_task(struct iscsi_conn *conn,
 {
 	struct iscsi_task *task;
 
-	if (!kfifo_out(&conn->session->cmdpool.queue,
+	if (!__kfifo_get(conn->session->cmdpool.queue,
 			 (void *) &task, sizeof(void *)))
 		return NULL;
 
@@ -1717,7 +1717,11 @@ reject:
 	ISCSI_DBG_SESSION(session, "cmd 0x%x rejected (%d)\n",
 			  sc->cmnd[0], reason);
 	spin_lock(host->host_lock);
+#if (defined RHELC1) || (defined SLEC1)
+	return SCSI_MLQUEUE_DEVICE_BUSY;
+#else
 	return SCSI_MLQUEUE_TARGET_BUSY;
+#endif
 
 prepd_fault:
 	sc->scsi_done = NULL;
@@ -1726,33 +1730,16 @@ fault:
 	spin_unlock(&session->lock);
 	ISCSI_DBG_SESSION(session, "iscsi: cmd 0x%x is not queued (%d)\n",
 			  sc->cmnd[0], reason);
-	if (!scsi_bidi_cmnd(sc))
-		scsi_set_resid(sc, scsi_bufflen(sc));
-	else {
-		scsi_out(sc)->resid = scsi_out(sc)->length;
-		scsi_in(sc)->resid = scsi_in(sc)->length;
-	}
+	scsi_set_resid(sc, scsi_bufflen(sc));
 	done(sc);
 	spin_lock(host->host_lock);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iscsi_queuecommand);
 
-int iscsi_change_queue_depth(struct scsi_device *sdev, int depth, int reason)
+int iscsi_change_queue_depth(struct scsi_device *sdev, int depth)
 {
-	switch (reason) {
-	case SCSI_QDEPTH_DEFAULT:
-		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
-		break;
-	case SCSI_QDEPTH_QFULL:
-		scsi_track_queue_full(sdev, depth);
-		break;
-	case SCSI_QDEPTH_RAMP_UP:
-		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
+	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
 	return sdev->queue_depth;
 }
 EXPORT_SYMBOL_GPL(iscsi_change_queue_depth);
@@ -2524,7 +2511,12 @@ iscsi_pool_init(struct iscsi_pool *q, int max, void ***items, int item_size)
 	if (q->pool == NULL)
 		return -ENOMEM;
 
-	kfifo_init(&q->queue, (void*)q->pool, max * sizeof(void*));
+	q->queue = kfifo_init((void*)q->pool, max * sizeof(void*),
+			      GFP_KERNEL, NULL);
+	if (IS_ERR(q->queue)) {
+		q->queue = NULL;
+		goto enomem;
+	}
 
 	for (i = 0; i < max; i++) {
 		q->pool[i] = kzalloc(item_size, GFP_KERNEL);
@@ -2532,7 +2524,7 @@ iscsi_pool_init(struct iscsi_pool *q, int max, void ***items, int item_size)
 			q->max = i;
 			goto enomem;
 		}
-		kfifo_in(&q->queue, (void*)&q->pool[i], sizeof(void*));
+		__kfifo_put(q->queue, (void*)&q->pool[i], sizeof(void*));
 	}
 
 	if (items) {
@@ -2555,6 +2547,7 @@ void iscsi_pool_free(struct iscsi_pool *q)
 	for (i = 0; i < q->max; i++)
 		kfree(q->pool[i]);
 	kfree(q->pool);
+	kfree(q->queue);
 }
 EXPORT_SYMBOL_GPL(iscsi_pool_free);
 
@@ -2882,7 +2875,7 @@ iscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,
 
 	/* allocate login_task used for the login/text sequences */
 	spin_lock_bh(&session->lock);
-	if (!kfifo_out(&session->cmdpool.queue,
+	if (!__kfifo_get(session->cmdpool.queue,
                          (void*)&conn->login_task,
 			 sizeof(void*))) {
 		spin_unlock_bh(&session->lock);
@@ -2902,7 +2895,7 @@ iscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,
 	return cls_conn;
 
 login_task_data_alloc_fail:
-	kfifo_in(&session->cmdpool.queue, (void*)&conn->login_task,
+	__kfifo_put(session->cmdpool.queue, (void*)&conn->login_task,
 		    sizeof(void*));
 login_task_alloc_fail:
 	iscsi_destroy_conn(cls_conn);
@@ -2965,7 +2958,7 @@ void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
 	free_pages((unsigned long) conn->data,
 		   get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));
 	kfree(conn->persistent_address);
-	kfifo_in(&session->cmdpool.queue, (void*)&conn->login_task,
+	__kfifo_put(session->cmdpool.queue, (void*)&conn->login_task,
 		    sizeof(void*));
 	if (session->leadconn == conn)
 		session->leadconn = NULL;
diff --git a/libiscsi.h b/libiscsi.h
index 0563539..4be9333 100644
--- a/libiscsi.h
+++ b/libiscsi.h
@@ -231,7 +231,7 @@ struct iscsi_conn {
 };
 
 struct iscsi_pool {
-	struct kfifo		queue;		/* FIFO Queue */
+	struct kfifo		*queue;		/* FIFO Queue */
 	void			**pool;		/* Pool of elements */
 	int			max;		/* Max number of elements */
 };
@@ -334,8 +334,7 @@ struct iscsi_host {
 /*
  * scsi host template
  */
-extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth,
-				    int reason);
+extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
 extern int iscsi_eh_abort(struct scsi_cmnd *sc);
 extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
 extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);
diff --git a/libiscsi_tcp.c b/libiscsi_tcp.c
index 1122de4..c590df2 100644
--- a/libiscsi_tcp.c
+++ b/libiscsi_tcp.c
@@ -361,6 +361,17 @@ iscsi_segment_seek_sg(struct iscsi_segment *segment,
 	struct scatterlist *sg;
 	unsigned int i;
 
+	/*
+	 * older kernels could send use_sg=0 for commands like sgio
+	 * or scsi-ml commands.
+	 */
+
+	if (!sg_count) {
+		iscsi_segment_init_linear(segment, (void *)sg_list + offset,
+					size, done, hash);
+		return 0;
+	}
+
 	__iscsi_segment_init(segment, size, done, hash);
 	for_each_sg(sg_list, sg, sg_count, i) {
 		if (offset < sg->length) {
@@ -446,15 +457,15 @@ void iscsi_tcp_cleanup_task(struct iscsi_task *task)
 		return;
 
 	/* flush task's r2t queues */
-	while (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
-		kfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,
+	while (__kfifo_get(tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
+		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		ISCSI_DBG_TCP(task->conn, "pending r2t dropped\n");
 	}
 
 	r2t = tcp_task->r2t;
 	if (r2t != NULL) {
-		kfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,
+		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		tcp_task->r2t = NULL;
 	}
@@ -472,7 +483,7 @@ static int iscsi_tcp_data_in(struct iscsi_conn *conn, struct iscsi_task *task)
 	struct iscsi_tcp_task *tcp_task = task->dd_data;
 	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn->in.hdr;
 	int datasn = be32_to_cpu(rhdr->datasn);
-	unsigned total_in_length = scsi_in(task->sc)->length;
+	unsigned total_in_length = scsi_bufflen(task->sc);
 
 	/*
 	 * lib iscsi will update this in the completion handling if there
@@ -542,7 +553,7 @@ static int iscsi_tcp_r2t_rsp(struct iscsi_conn *conn, struct iscsi_task *task)
 		return 0;
 	}
 
-	rc = kfifo_out(&tcp_task->r2tpool.queue, (void*)&r2t, sizeof(void*));
+	rc = __kfifo_get(tcp_task->r2tpool.queue, (void*)&r2t, sizeof(void*));
 	if (!rc) {
 		iscsi_conn_printk(KERN_ERR, conn, "Could not allocate R2T. "
 				  "Target has sent more R2Ts than it "
@@ -555,7 +566,7 @@ static int iscsi_tcp_r2t_rsp(struct iscsi_conn *conn, struct iscsi_task *task)
 	if (r2t->data_length == 0) {
 		iscsi_conn_printk(KERN_ERR, conn,
 				  "invalid R2T with zero data len\n");
-		kfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,
+		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
 	}
@@ -566,12 +577,12 @@ static int iscsi_tcp_r2t_rsp(struct iscsi_conn *conn, struct iscsi_task *task)
 			      r2t->data_length, session->max_burst);
 
 	r2t->data_offset = be32_to_cpu(rhdr->data_offset);
-	if (r2t->data_offset + r2t->data_length > scsi_out(task->sc)->length) {
+	if (r2t->data_offset + r2t->data_length > scsi_bufflen(task->sc)) {
 		iscsi_conn_printk(KERN_ERR, conn,
 				  "invalid R2T with data len %u at offset %u "
 				  "and total length %d\n", r2t->data_length,
-				  r2t->data_offset, scsi_out(task->sc)->length);
-		kfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,
+				  r2t->data_offset, scsi_bufflen(task->sc));
+		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
 	}
@@ -581,7 +592,7 @@ static int iscsi_tcp_r2t_rsp(struct iscsi_conn *conn, struct iscsi_task *task)
 	r2t->sent = 0;
 
 	tcp_task->exp_datasn = r2tsn + 1;
-	kfifo_in(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*));
+	__kfifo_put(tcp_task->r2tqueue, (void*)&r2t, sizeof(void*));
 	conn->r2t_pdus_cnt++;
 
 	iscsi_requeue_task(task);
@@ -669,7 +680,6 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 		if (tcp_conn->in.datalen) {
 			struct iscsi_tcp_task *tcp_task = task->dd_data;
 			struct hash_desc *rx_hash = NULL;
-			struct scsi_data_buffer *sdb = scsi_in(task->sc);
 
 			/*
 			 * Setup copy of Data-In into the Scsi_Cmnd
@@ -689,8 +699,8 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 				      tcp_conn->in.datalen);
 			task->last_xfer = jiffies;
 			rc = iscsi_segment_seek_sg(&tcp_conn->in.segment,
-						   sdb->table.sgl,
-						   sdb->table.nents,
+						   scsi_sglist(task->sc),
+						   scsi_sg_count(task->sc),
 						   tcp_task->data_offset,
 						   tcp_conn->in.datalen,
 						   iscsi_tcp_process_data_in,
@@ -952,7 +962,7 @@ int iscsi_tcp_task_init(struct iscsi_task *task)
 		return conn->session->tt->init_pdu(task, 0, task->data_count);
 	}
 
-	BUG_ON(kfifo_len(&tcp_task->r2tqueue));
+	BUG_ON(__kfifo_len(tcp_task->r2tqueue));
 	tcp_task->exp_datasn = 0;
 
 	/* Prepare PDU, optionally w/ immediate data */
@@ -983,7 +993,7 @@ static struct iscsi_r2t_info *iscsi_tcp_get_curr_r2t(struct iscsi_task *task)
 			if (r2t->data_length <= r2t->sent) {
 				ISCSI_DBG_TCP(task->conn,
 					      "  done with r2t %p\n", r2t);
-				kfifo_in(&tcp_task->r2tpool.queue,
+				__kfifo_put(tcp_task->r2tpool.queue,
 					    (void *)&tcp_task->r2t,
 					    sizeof(void *));
 				tcp_task->r2t = r2t = NULL;
@@ -991,12 +1001,9 @@ static struct iscsi_r2t_info *iscsi_tcp_get_curr_r2t(struct iscsi_task *task)
 		}
 
 		if (r2t == NULL) {
-			if (kfifo_out(&tcp_task->r2tqueue,
-			    (void *)&tcp_task->r2t, sizeof(void *)) !=
-			    sizeof(void *))
-				r2t = NULL;
-			else
-				r2t = tcp_task->r2t;
+			__kfifo_get(tcp_task->r2tqueue,
+				    (void *)&tcp_task->r2t, sizeof(void *));
+			r2t = tcp_task->r2t;
 		}
 		spin_unlock_bh(&session->lock);
 	}
@@ -1131,8 +1138,9 @@ int iscsi_tcp_r2tpool_alloc(struct iscsi_session *session)
 		}
 
 		/* R2T xmit queue */
-		if (kfifo_alloc(&tcp_task->r2tqueue,
-		      session->max_r2t * 4 * sizeof(void*), GFP_KERNEL)) {
+		tcp_task->r2tqueue = kfifo_alloc(
+		      session->max_r2t * 4 * sizeof(void*), GFP_KERNEL, NULL);
+		if (tcp_task->r2tqueue == ERR_PTR(-ENOMEM)) {
 			iscsi_pool_free(&tcp_task->r2tpool);
 			goto r2t_alloc_fail;
 		}
@@ -1145,7 +1153,7 @@ r2t_alloc_fail:
 		struct iscsi_task *task = session->cmds[i];
 		struct iscsi_tcp_task *tcp_task = task->dd_data;
 
-		kfifo_free(&tcp_task->r2tqueue);
+		kfifo_free(tcp_task->r2tqueue);
 		iscsi_pool_free(&tcp_task->r2tpool);
 	}
 	return -ENOMEM;
@@ -1160,7 +1168,7 @@ void iscsi_tcp_r2tpool_free(struct iscsi_session *session)
 		struct iscsi_task *task = session->cmds[i];
 		struct iscsi_tcp_task *tcp_task = task->dd_data;
 
-		kfifo_free(&tcp_task->r2tqueue);
+		kfifo_free(tcp_task->r2tqueue);
 		iscsi_pool_free(&tcp_task->r2tpool);
 	}
 }
diff --git a/libiscsi_tcp.h b/libiscsi_tcp.h
index c020eee..3bacef5 100644
--- a/libiscsi_tcp.h
+++ b/libiscsi_tcp.h
@@ -80,7 +80,7 @@ struct iscsi_tcp_task {
 	int			data_offset;
 	struct iscsi_r2t_info	*r2t;		/* in progress solict R2T */
 	struct iscsi_pool	r2tpool;
-	struct kfifo		r2tqueue;
+	struct kfifo		*r2tqueue;
 	void			*dd_data;
 };
 
diff --git a/open_iscsi_compat.h b/open_iscsi_compat.h
new file mode 100644
index 0000000..e6511d3
--- /dev/null
+++ b/open_iscsi_compat.h
@@ -0,0 +1,399 @@
+#ifndef OPEN_ISCSI_COMPAT
+#define OPEN_ISCSI_COMPAT
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_host.h>
+
+#ifndef SCAN_WILD_CARD
+#define SCAN_WILD_CARD  ~0
+#endif
+
+#ifndef NIPQUAD_FMT
+#define NIPQUAD_FMT "%u.%u.%u.%u"
+#endif
+
+#ifndef NIP6_FMT
+#define NIP6_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+#endif
+
+#ifndef DEFINE_MUTEX
+
+/* mutex changes from 2.6.16-rc1 and up */
+#define DEFINE_MUTEX DECLARE_MUTEX
+#define mutex_lock down
+#define mutex_unlock up
+#define mutex semaphore
+#define mutex_init init_MUTEX
+#endif
+
+#ifdef RHEL_RELEASE_CODE
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6, 0))
+#define RHELC1	1
+#endif
+#endif
+
+#ifdef SLE_VERSION_CODE
+#if (SLE_VERSION_CODE < SLE_VERSION(11, 0, 0))
+#define SLEC1	1
+#endif
+#endif
+
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,19) 
+struct delayed_work {
+	struct work_struct work;
+};
+
+#define cancel_delayed_work(_dwork) cancel_delayed_work(&(_dwork)->work)
+#define INIT_DELAYED_WORK(_work,_func) INIT_WORK(&(_work)->work, _func)
+
+static inline void INIT_WORK_compat(struct work_struct *work, void *func)
+{
+	INIT_WORK(work, func, work);
+}
+
+#undef INIT_WORK
+#define INIT_WORK(_work, _func) INIT_WORK_compat(_work, _func)
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
+
+void int_to_scsilun(unsigned int lun, struct scsi_lun *scsilun)
+{
+	int i;
+
+	memset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));
+
+	for (i = 0; i < sizeof(lun); i += 2) {
+		scsilun->scsi_lun[i] = (lun >> 8) & 0xFF;
+		scsilun->scsi_lun[i+1] = lun & 0xFF;
+		lun = lun >> 16;
+	}
+}
+
+#define __nlmsg_put(skb, daemon_pid, seq, type, len, flags) \
+	__nlmsg_put(skb, daemon_pid, 0, 0, len)
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13) 
+#ifdef RHEL_RELEASE_CODE && \
+	RHEL_RELEASE_CODE != RHEL_RELEASE_VERSION(4,8)
+
+#define gfp_t unsigned
+
+void *kzalloc(size_t size, gfp_t flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+}
+
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+
+#include "linux/crypto.h"
+
+#if !defined SLEC1
+#define CRYPTO_ALG_ASYNC		0x00000080
+struct hash_desc
+{
+	struct crypto_tfm *tfm;
+	u32 flags;
+};
+
+static inline int crypto_hash_init(struct hash_desc *desc)
+{
+	crypto_digest_init(desc->tfm);
+	return 0;
+}
+
+static inline int crypto_hash_digest(struct hash_desc *desc,
+				     struct scatterlist *sg,
+				     unsigned int nbytes, u8 *out)
+{
+	crypto_digest_digest(desc->tfm, sg, 1, out);
+	return nbytes;
+}
+
+static inline int crypto_hash_update(struct hash_desc *desc,
+				     struct scatterlist *sg,
+				     unsigned int nbytes)
+{
+	crypto_digest_update(desc->tfm, sg, 1);
+	return nbytes;
+}
+
+static inline int crypto_hash_final(struct hash_desc *desc, u8 *out)
+{
+	crypto_digest_final(desc->tfm, out);
+	return 0;
+}
+
+static inline struct crypto_tfm *crypto_alloc_hash(const char *alg_name,
+						    u32 type, u32 mask)
+{
+	struct crypto_tfm *ret = crypto_alloc_tfm(alg_name ,type);
+	return ret ? ret : ERR_PTR(-ENOMEM);
+}
+
+static inline void crypto_free_hash(struct crypto_tfm *tfm)
+{
+	crypto_free_tfm(tfm);
+}
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)) \
+       && !(defined RHELC1)
+static inline int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+			int *addrlen)
+{
+	return sock->ops->getname(sock, addr, addrlen, 0);
+}
+
+static inline int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+			int *addrlen)
+{
+	return sock->ops->getname(sock, addr, addrlen, 1);
+}
+#endif
+#endif
+
+#ifndef bool
+#define bool int
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,20)
+#ifdef RHEL_RELEASE_VERSION
+#if RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,2) && \
+	RHEL_RELEASE_CODE != RHEL_RELEASE_VERSION(4,8)
+static inline int is_power_of_2(unsigned long n)
+{
+	return (n != 0 && ((n & (n - 1)) == 0));
+}
+#endif
+#else
+/* not a redhat kernel */
+static inline int is_power_of_2(unsigned long n)
+{
+	return (n != 0 && ((n & (n - 1)) == 0));
+}
+#endif
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,21)
+
+static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
+{
+	return (struct nlmsghdr *)skb->data;
+}
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
+#ifdef RHEL_RELEASE_VERSION
+#if RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,2)
+static inline void *shost_priv(struct Scsi_Host *shost)
+{
+	return (void *)shost->hostdata;
+}
+#endif
+#else
+/* not a redhat kernel */
+static inline void *shost_priv(struct Scsi_Host *shost)
+{
+	return (void *)shost->hostdata;
+}
+#endif
+ 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)) && \
+				!defined(SLEC1)
+/**
+ * scsilun_to_int: convert a scsi_lun to an int
+ * @scsilun:	struct scsi_lun to be converted.
+ *
+ * Description:
+ *     Convert @scsilun from a struct scsi_lun to a four byte host byte-ordered
+ *     integer, and return the result. The caller must check for
+ *     truncation before using this function.
+ *
+ * Notes:
+ *     The struct scsi_lun is assumed to be four levels, with each level
+ *     effectively containing a SCSI byte-ordered (big endian) short; the
+ *     addressing bits of each level are ignored (the highest two bits).
+ *     For a description of the LUN format, post SCSI-3 see the SCSI
+ *     Architecture Model, for SCSI-3 see the SCSI Controller Commands.
+ *
+ *     Given a struct scsi_lun of: 0a 04 0b 03 00 00 00 00, this function returns
+ *     the integer: 0x0b030a04
+ **/
+static inline int scsilun_to_int(struct scsi_lun *scsilun)
+{
+	int i;
+	unsigned int lun;
+
+	lun = 0;
+	for (i = 0; i < sizeof(lun); i += 2)
+		lun = lun | (((scsilun->scsi_lun[i] << 8) |
+			      scsilun->scsi_lun[i + 1]) << (i * 8));
+	return lun;
+}
+#endif
+
+/*
+ * Note: We do not support bidi for the compat modules if the kernel
+ * does not have support.
+ */
+#define scsi_sg_count(cmd) ((cmd)->use_sg)
+#define scsi_sglist(cmd) ((struct scatterlist *)(cmd)->request_buffer)
+#define scsi_bufflen(cmd) ((cmd)->request_bufflen)
+
+#ifdef RHEL_RELEASE_VERSION
+#if RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,2)
+static inline void scsi_set_resid(struct scsi_cmnd *cmd, int resid)
+{
+	cmd->resid = resid;
+}
+
+static inline int scsi_get_resid(struct scsi_cmnd *cmd)
+{
+	return cmd->resid;
+}
+#endif
+#else
+/* not a redhat kernel */
+static inline void scsi_set_resid(struct scsi_cmnd *cmd, int resid)
+{
+	cmd->resid = resid;
+}
+
+static inline int scsi_get_resid(struct scsi_cmnd *cmd)
+{
+	return cmd->resid;
+}
+#endif
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
+
+#ifdef	SLE_VERSION_CODE
+#if SLE_VERSION_CODE == SLE_VERSION(10,2,0)
+ 
+static inline unsigned fls_long(unsigned long l)
+{
+	if (sizeof(l) == 4)
+		return fls(l);
+	return fls64(l);
+}
+
+#endif
+#endif
+
+static inline unsigned long rounddown_pow_of_two(unsigned long n)
+{
+	return 1UL << (fls_long(n) - 1);
+}
+
+
+static inline struct scatterlist *sg_next(struct scatterlist *sg)
+{
+	if (!sg) {
+		BUG();
+		return NULL;
+	}
+	return sg + 1;
+}
+
+#define for_each_sg(sglist, sg, nr, __i)        \
+	for (__i = 0, sg = (sglist); __i < (nr); __i++, sg = sg_next(sg))
+
+#define sg_page(_sg) _sg->page
+
+static inline void sg_set_page(struct scatterlist *sg, struct page *page,
+				unsigned int len, unsigned int offset)
+{
+	sg->page = page;
+	sg->offset = offset;
+	sg->length = len;
+}
+
+static inline void sg_init_table(struct scatterlist *sgl, unsigned int nents)
+{
+	memset(sgl, 0, sizeof(*sgl) * nents);
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,24)
+
+static inline int scsi_bidi_cmnd(struct scsi_cmnd *cmd)
+{
+	return 0;
+}
+
+#define netlink_kernel_release(_nls) \
+	sock_release(_nls->sk_socket)
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13)
+
+#define netlink_kernel_create(net, uint, groups, input, cb_mutex, mod) \
+	netlink_kernel_create(uint, groups, input, cb_mutex, mod)
+
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,21)
+
+#define netlink_kernel_create(net, uint, groups, input, cb_mutex, mod) \
+	netlink_kernel_create(uint, groups, input, mod)
+
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
+
+#define netlink_kernel_create(net, uint, groups, input, cb_mutex, mod) \
+	netlink_kernel_create(uint, groups, input, cb_mutex, mod)
+
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
+
+#define netlink_kernel_create(net, uint, groups, input, cb_mutex, mod) \
+	netlink_kernel_create(uint, groups, input, cb_mutex, mod)
+
+#endif
+
+#ifndef DID_TRANSPORT_DISRUPTED
+#define DID_TRANSPORT_DISRUPTED DID_BUS_BUSY
+#endif
+
+#ifndef DID_TRANSPORT_FAILFAST
+#define DID_TRANSPORT_FAILFAST DID_NO_CONNECT
+#endif
+
+#ifndef SCSI_MLQUEUE_TARGET_BUSY
+#define SCSI_MLQUEUE_TARGET_BUSY SCSI_MLQUEUE_HOST_BUSY
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27)
+
+#define BLK_EH_NOT_HANDLED EH_NOT_HANDLED
+#define BLK_EH_RESET_TIMER EH_RESET_TIMER
+
+#define blk_eh_timer_return scsi_eh_timer_return
+
+#endif
+
+#ifndef	SCSI_MAX_VARLEN_CDB_SIZE
+#define	SCSI_MAX_VARLEN_CDB_SIZE 16
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34)
+
+static inline wait_queue_head_t *sk_sleep(struct sock *sk)
+{
+	return sk->sk_sleep;
+}
+
+#endif
+
+#endif
diff --git a/scsi_transport_iscsi.c b/scsi_transport_iscsi.c
index fed8c9e..362bd4d 100644
--- a/scsi_transport_iscsi.c
+++ b/scsi_transport_iscsi.c
@@ -73,13 +73,13 @@ struct iscsi_internal {
 	struct scsi_transport_template t;
 	struct iscsi_transport *iscsi_transport;
 	struct list_head list;
-	struct device dev;
+	struct class_device cdev;
 
-	struct device_attribute *host_attrs[ISCSI_HOST_ATTRS + 1];
+	struct class_device_attribute *host_attrs[ISCSI_HOST_ATTRS + 1];
 	struct transport_container conn_cont;
-	struct device_attribute *conn_attrs[ISCSI_CONN_ATTRS + 1];
+	struct class_device_attribute *conn_attrs[ISCSI_CONN_ATTRS + 1];
 	struct transport_container session_cont;
-	struct device_attribute *session_attrs[ISCSI_SESSION_ATTRS + 1];
+	struct class_device_attribute *session_attrs[ISCSI_SESSION_ATTRS + 1];
 };
 
 static atomic_t iscsi_session_nr; /* sysfs session id for next new session */
@@ -96,12 +96,12 @@ static DEFINE_SPINLOCK(iscsi_transport_lock);
 #define to_iscsi_internal(tmpl) \
 	container_of(tmpl, struct iscsi_internal, t)
 
-#define dev_to_iscsi_internal(_dev) \
-	container_of(_dev, struct iscsi_internal, dev)
+#define cdev_to_iscsi_internal(_cdev) \
+	container_of(_cdev, struct iscsi_internal, cdev)
 
-static void iscsi_transport_release(struct device *dev)
+static void iscsi_transport_release(struct class_device *cdev)
 {
-	struct iscsi_internal *priv = dev_to_iscsi_internal(dev);
+	struct iscsi_internal *priv = cdev_to_iscsi_internal(cdev);
 	kfree(priv);
 }
 
@@ -111,33 +111,31 @@ static void iscsi_transport_release(struct device *dev)
  */
 static struct class iscsi_transport_class = {
 	.name = "iscsi_transport",
-	.dev_release = iscsi_transport_release,
+	.release = iscsi_transport_release,
 };
 
 static ssize_t
-show_transport_handle(struct device *dev, struct device_attribute *attr,
-		      char *buf)
+show_transport_handle(struct class_device *cdev, char *buf)
 {
-	struct iscsi_internal *priv = dev_to_iscsi_internal(dev);
+	struct iscsi_internal *priv = cdev_to_iscsi_internal(cdev);
 	return sprintf(buf, "%llu\n", (unsigned long long)iscsi_handle(priv->iscsi_transport));
 }
-static DEVICE_ATTR(handle, S_IRUGO, show_transport_handle, NULL);
+static CLASS_DEVICE_ATTR(handle, S_IRUGO, show_transport_handle, NULL);
 
 #define show_transport_attr(name, format)				\
 static ssize_t								\
-show_transport_##name(struct device *dev, 				\
-		      struct device_attribute *attr,char *buf)		\
+show_transport_##name(struct class_device *cdev, char *buf)		\
 {									\
-	struct iscsi_internal *priv = dev_to_iscsi_internal(dev);	\
+	struct iscsi_internal *priv = cdev_to_iscsi_internal(cdev);	\
 	return sprintf(buf, format"\n", priv->iscsi_transport->name);	\
 }									\
-static DEVICE_ATTR(name, S_IRUGO, show_transport_##name, NULL);
+static CLASS_DEVICE_ATTR(name, S_IRUGO, show_transport_##name, NULL);
 
 show_transport_attr(caps, "0x%x");
 
 static struct attribute *iscsi_transport_attrs[] = {
-	&dev_attr_handle.attr,
-	&dev_attr_caps.attr,
+	&class_device_attr_handle.attr,
+	&class_device_attr_caps.attr,
 	NULL,
 };
 
@@ -155,27 +153,28 @@ static struct attribute_group iscsi_transport_group = {
 struct device_attribute dev_attr_##_prefix##_##_name =	\
         __ATTR(_name,_mode,_show,_store)
 
-static void iscsi_endpoint_release(struct device *dev)
+static void iscsi_endpoint_release(struct class_device *cdev)
 {
-	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
+	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(cdev);
 	kfree(ep);
 }
 
 static struct class iscsi_endpoint_class = {
 	.name = "iscsi_endpoint",
-	.dev_release = iscsi_endpoint_release,
+	.release = iscsi_endpoint_release,
 };
 
 static ssize_t
-show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
+show_ep_handle(struct class_device *cdev, char *buf)
 {
-	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
+	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(cdev);
 	return sprintf(buf, "%llu\n", (unsigned long long) ep->id);
 }
-static ISCSI_ATTR(ep, handle, S_IRUGO, show_ep_handle, NULL);
+static struct class_device_attribute class_device_attr_ep_handle =
+	__ATTR(handle, S_IRUGO, show_ep_handle, NULL);
 
 static struct attribute *iscsi_endpoint_attrs[] = {
-	&dev_attr_ep_handle.attr,
+	&class_device_attr_ep_handle.attr,
 	NULL,
 };
 
@@ -185,26 +184,15 @@ static struct attribute_group iscsi_endpoint_group = {
 
 #define ISCSI_MAX_EPID -1
 
-static int iscsi_match_epid(struct device *dev, void *data)
-{
-	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
-	uint64_t *epid = (uint64_t *) data;
-
-	return *epid == ep->id;
-}
-
 struct iscsi_endpoint *
 iscsi_create_endpoint(int dd_size)
 {
-	struct device *dev;
 	struct iscsi_endpoint *ep;
 	uint64_t id;
 	int err;
 
 	for (id = 1; id < ISCSI_MAX_EPID; id++) {
-		dev = class_find_device(&iscsi_endpoint_class, NULL, &id,
-					iscsi_match_epid);
-		if (!dev)
+		if (!iscsi_lookup_endpoint(id))
 			break;
 	}
 	if (id == ISCSI_MAX_EPID) {
@@ -219,8 +207,9 @@ iscsi_create_endpoint(int dd_size)
 
 	ep->id = id;
 	ep->dev.class = &iscsi_endpoint_class;
-	dev_set_name(&ep->dev, "ep-%llu", (unsigned long long) id);
-	err = device_register(&ep->dev);
+	snprintf(ep->dev.class_id, BUS_ID_SIZE, "ep-%llu",
+			(unsigned long long) id);
+	err = class_device_register(&ep->dev);
         if (err)
                 goto free_ep;
 
@@ -233,7 +222,7 @@ iscsi_create_endpoint(int dd_size)
 	return ep;
 
 unregister_dev:
-	device_unregister(&ep->dev);
+	class_device_unregister(&ep->dev);
 	return NULL;
 
 free_ep:
@@ -245,32 +234,38 @@ EXPORT_SYMBOL_GPL(iscsi_create_endpoint);
 void iscsi_destroy_endpoint(struct iscsi_endpoint *ep)
 {
 	sysfs_remove_group(&ep->dev.kobj, &iscsi_endpoint_group);
-	device_unregister(&ep->dev);
+	class_device_unregister(&ep->dev);
 }
 EXPORT_SYMBOL_GPL(iscsi_destroy_endpoint);
 
 struct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle)
 {
-	struct iscsi_endpoint *ep;
-	struct device *dev;
-
-	dev = class_find_device(&iscsi_endpoint_class, NULL, &handle,
-				iscsi_match_epid);
-	if (!dev)
-		return NULL;
+	struct iscsi_endpoint *ep = NULL;
+	struct class_device *cdev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) 
+	down_read(&iscsi_endpoint_class.subsys.rwsem);
+#else
+	spin_lock(&iscsi_endpoint_class.subsys.list_lock);
+#endif
+	list_for_each_entry(cdev, &iscsi_endpoint_class.children, node) {
+		ep = iscsi_dev_to_endpoint(cdev);
+		if (ep->id == handle)
+			break;
+		ep = NULL;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	up_read(&iscsi_endpoint_class.subsys.rwsem);
+#else
+	spin_unlock(&iscsi_endpoint_class.subsys.list_lock);
+#endif
 
-	ep = iscsi_dev_to_endpoint(dev);
-	/*
-	 * we can drop this now because the interface will prevent
-	 * removals and lookups from racing.
-	 */
-	put_device(dev);
 	return ep;
 }
 EXPORT_SYMBOL_GPL(iscsi_lookup_endpoint);
 
 static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
-			    struct device *cdev)
+			    struct class_device *cdev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct iscsi_cls_host *ihost = shost->shost_data;
@@ -571,8 +566,6 @@ static void __iscsi_unblock_session(struct work_struct *work)
 	struct iscsi_cls_session *session =
 			container_of(work, struct iscsi_cls_session,
 				     unblock_work);
-	struct Scsi_Host *shost = iscsi_session_to_shost(session);
-	struct iscsi_cls_host *ihost = shost->shost_data;
 	unsigned long flags;
 
 	ISCSI_DBG_TRANS_SESSION(session, "Unblocking session\n");
@@ -586,15 +579,6 @@ static void __iscsi_unblock_session(struct work_struct *work)
 	spin_unlock_irqrestore(&session->lock, flags);
 	/* start IO */
 	scsi_target_unblock(&session->dev);
-	/*
-	 * Only do kernel scanning if the driver is properly hooked into
-	 * the async scanning code (drivers like iscsi_tcp do login and
-	 * scanning from userspace).
-	 */
-	if (shost->hostt->scan_finished) {
-		if (scsi_queue_work(shost, &session->scan_work))
-			atomic_inc(&ihost->nr_scans);
-	}
 	ISCSI_DBG_TRANS_SESSION(session, "Completed unblocking session\n");
 }
 
@@ -750,7 +734,7 @@ int iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)
 	}
 	session->target_id = id;
 
-	dev_set_name(&session->dev, "session%u", session->sid);
+	snprintf(session->dev.bus_id, BUS_ID_SIZE, "session%u", session->sid);
 	err = device_add(&session->dev);
 	if (err) {
 		iscsi_cls_session_printk(KERN_ERR, session,
@@ -930,7 +914,8 @@ iscsi_create_conn(struct iscsi_cls_session *session, int dd_size, uint32_t cid)
 	if (!get_device(&session->dev))
 		goto free_conn;
 
-	dev_set_name(&conn->dev, "connection%d:%u", session->sid, cid);
+	snprintf(conn->dev.bus_id, BUS_ID_SIZE, "connection%d:%u",
+			session->sid, cid);
 	conn->dev.parent = &session->dev;
 	conn->dev.release = iscsi_conn_release;
 	err = device_register(&conn->dev);
@@ -1003,7 +988,15 @@ iscsi_if_transport_lookup(struct iscsi_transport *tt)
 static int
 iscsi_multicast_skb(struct sk_buff *skb, uint32_t group, gfp_t gfp)
 {
-	return nlmsg_multicast(nls, skb, 0, group, gfp);
+	int err;
+
+	NETLINK_CB(skb).dst_group = group;
+	
+	err = netlink_broadcast(nls, skb, 0, group, gfp);
+	if (err > 0)
+		err = 0;
+
+	return err;
 }
 
 int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
@@ -1643,51 +1636,65 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)
  * Malformed skbs with wrong lengths or invalid creds are not processed.
  */
 static void
-iscsi_if_rx(struct sk_buff *skb)
+iscsi_if_rx(struct sock *sk, int len)
 {
-	mutex_lock(&rx_queue_mutex);
-	while (skb->len >= NLMSG_SPACE(0)) {
-		int err;
-		uint32_t rlen;
-		struct nlmsghdr	*nlh;
-		struct iscsi_uevent *ev;
-		uint32_t group;
-
-		nlh = nlmsg_hdr(skb);
-		if (nlh->nlmsg_len < sizeof(*nlh) ||
-		    skb->len < nlh->nlmsg_len) {
-			break;
-		}
-
-		ev = NLMSG_DATA(nlh);
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
+	struct sk_buff *skb;
 
-		err = iscsi_if_recv_msg(skb, nlh, &group);
-		if (err) {
-			ev->type = ISCSI_KEVENT_IF_ERROR;
-			ev->iferror = err;
+	mutex_lock(&rx_queue_mutex);
+	while ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {
+		if (NETLINK_CREDS(skb)->uid) {
+			skb_pull(skb, skb->len);
+			goto free_skb;
 		}
-		do {
-			/*
-			 * special case for GET_STATS:
-			 * on success - sending reply and stats from
-			 * inside of if_recv_msg(),
-			 * on error - fall through.
-			 */
-			if (ev->type == ISCSI_UEVENT_GET_STATS && !err)
+	
+		while (skb->len >= NLMSG_SPACE(0)) {
+			int err;
+			uint32_t rlen;
+			struct nlmsghdr *nlh;
+			struct iscsi_uevent *ev;
+			uint32_t group;
+			
+			nlh = nlmsg_hdr(skb);
+			if (nlh->nlmsg_len < sizeof(*nlh) ||
+				skb->len < nlh->nlmsg_len) {
 				break;
-			err = iscsi_if_send_reply(group, nlh->nlmsg_seq,
-				nlh->nlmsg_type, 0, 0, ev, sizeof(*ev));
-		} while (err < 0 && err != -ECONNREFUSED);
-		skb_pull(skb, rlen);
+			}
+
+			ev = NLMSG_DATA(nlh);
+			rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+			if (rlen > skb->len)
+				rlen = skb->len;
+
+			err = iscsi_if_recv_msg(skb, nlh, &group);
+			if (err) {
+				ev->type = ISCSI_KEVENT_IF_ERROR;
+				ev->iferror = err;
+			}
+			do {
+				/*
+				 * special case for GET_STATS:
+				 * on success - sending reply and stats from
+				 * inside of if_recv_msg(),
+				 * on error - fall through.
+				 */
+				if (ev->type == ISCSI_UEVENT_GET_STATS && !err)
+					break;
+				err = iscsi_if_send_reply(group, nlh->nlmsg_seq,
+						nlh->nlmsg_type, 0, 0, ev, sizeof(*ev));
+			} while (err < 0 && err != -ECONNREFUSED);
+			skb_pull(skb, rlen);
+		}
+free_skb:
+		kfree_skb(skb);
 	}
 	mutex_unlock(&rx_queue_mutex);
 }
 
+#define iscsi_cdev_to_conn(_cdev) \
+	iscsi_dev_to_conn(_cdev->dev)
+
 #define ISCSI_CLASS_ATTR(_prefix,_name,_mode,_show,_store)		\
-struct device_attribute dev_attr_##_prefix##_##_name =	\
+struct class_device_attribute class_device_attr_##_prefix##_##_name =	\
 	__ATTR(_name,_mode,_show,_store)
 
 /*
@@ -1695,10 +1702,9 @@ struct device_attribute dev_attr_##_prefix##_##_name =	\
  */
 #define iscsi_conn_attr_show(param)					\
 static ssize_t								\
-show_conn_param_##param(struct device *dev, 				\
-			struct device_attribute *attr, char *buf)	\
+show_conn_param_##param(struct class_device *cdev, char *buf)		\
 {									\
-	struct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev->parent);	\
+	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
 	struct iscsi_transport *t = conn->transport;			\
 	return t->get_conn_param(conn, param, buf);			\
 }
@@ -1722,16 +1728,18 @@ iscsi_conn_attr(address, ISCSI_PARAM_CONN_ADDRESS);
 iscsi_conn_attr(ping_tmo, ISCSI_PARAM_PING_TMO);
 iscsi_conn_attr(recv_tmo, ISCSI_PARAM_RECV_TMO);
 
+#define iscsi_cdev_to_session(_cdev) \
+	iscsi_dev_to_session(_cdev->dev)
+
 /*
  * iSCSI session attrs
  */
 #define iscsi_session_attr_show(param, perm)				\
 static ssize_t								\
-show_session_param_##param(struct device *dev,				\
-			   struct device_attribute *attr, char *buf)	\
+show_session_param_##param(struct class_device *cdev, char *buf)	\
 {									\
 	struct iscsi_cls_session *session = 				\
-		iscsi_dev_to_session(dev->parent);			\
+		iscsi_cdev_to_session(cdev);				\
 	struct iscsi_transport *t = session->transport;			\
 									\
 	if (perm && !capable(CAP_SYS_ADMIN))				\
@@ -1766,10 +1774,9 @@ iscsi_session_attr(ifacename, ISCSI_PARAM_IFACE_NAME, 0);
 iscsi_session_attr(initiatorname, ISCSI_PARAM_INITIATOR_NAME, 0)
 
 static ssize_t
-show_priv_session_state(struct device *dev, struct device_attribute *attr,
-			char *buf)
+show_priv_session_state(struct class_device *cdev, char *buf)
 {
-	struct iscsi_cls_session *session = iscsi_dev_to_session(dev->parent);
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev);
 	return sprintf(buf, "%s\n", iscsi_session_state_name(session->state));
 }
 static ISCSI_CLASS_ATTR(priv_sess, state, S_IRUGO, show_priv_session_state,
@@ -1777,11 +1784,10 @@ static ISCSI_CLASS_ATTR(priv_sess, state, S_IRUGO, show_priv_session_state,
 
 #define iscsi_priv_session_attr_show(field, format)			\
 static ssize_t								\
-show_priv_session_##field(struct device *dev, 				\
-			  struct device_attribute *attr, char *buf)	\
+show_priv_session_##field(struct class_device *cdev, char *buf)		\
 {									\
 	struct iscsi_cls_session *session = 				\
-			iscsi_dev_to_session(dev->parent);		\
+			iscsi_cdev_to_session(cdev);			\
 	return sprintf(buf, format"\n", session->field);		\
 }
 
@@ -1796,10 +1802,9 @@ iscsi_priv_session_attr(recovery_tmo, "%d");
  */
 #define iscsi_host_attr_show(param)					\
 static ssize_t								\
-show_host_param_##param(struct device *dev, 				\
-			struct device_attribute *attr, char *buf)	\
+show_host_param_##param(struct class_device *cdev, char *buf)		\
 {									\
-	struct Scsi_Host *shost = transport_class_to_shost(dev);	\
+	struct Scsi_Host *shost = transport_class_to_shost(cdev);	\
 	struct iscsi_internal *priv = to_iscsi_internal(shost->transportt); \
 	return priv->iscsi_transport->get_host_param(shost, param, buf); \
 }
@@ -1816,7 +1821,7 @@ iscsi_host_attr(initiatorname, ISCSI_HOST_PARAM_INITIATOR_NAME);
 
 #define SETUP_PRIV_SESSION_RD_ATTR(field)				\
 do {									\
-	priv->session_attrs[count] = &dev_attr_priv_sess_##field; \
+	priv->session_attrs[count] = &class_device_attr_priv_sess_##field; \
 	count++;							\
 } while (0)
 
@@ -1824,7 +1829,7 @@ do {									\
 #define SETUP_SESSION_RD_ATTR(field, param_flag)			\
 do {									\
 	if (tt->param_mask & param_flag) {				\
-		priv->session_attrs[count] = &dev_attr_sess_##field; \
+		priv->session_attrs[count] = &class_device_attr_sess_##field; \
 		count++;						\
 	}								\
 } while (0)
@@ -1832,7 +1837,7 @@ do {									\
 #define SETUP_CONN_RD_ATTR(field, param_flag)				\
 do {									\
 	if (tt->param_mask & param_flag) {				\
-		priv->conn_attrs[count] = &dev_attr_conn_##field; \
+		priv->conn_attrs[count] = &class_device_attr_conn_##field; \
 		count++;						\
 	}								\
 } while (0)
@@ -1840,7 +1845,7 @@ do {									\
 #define SETUP_HOST_RD_ATTR(field, param_flag)				\
 do {									\
 	if (tt->host_param_mask & param_flag) {				\
-		priv->host_attrs[count] = &dev_attr_host_##field; \
+		priv->host_attrs[count] = &class_device_attr_host_##field; \
 		count++;						\
 	}								\
 } while (0)
@@ -1931,15 +1936,15 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	priv->t.user_scan = iscsi_user_scan;
 	priv->t.create_work_queue = 1;
 
-	priv->dev.class = &iscsi_transport_class;
-	dev_set_name(&priv->dev, "%s", tt->name);
-	err = device_register(&priv->dev);
+	priv->cdev.class = &iscsi_transport_class;
+	snprintf(priv->cdev.class_id, BUS_ID_SIZE, "%s", tt->name);
+	err = class_device_register(&priv->cdev);
 	if (err)
 		goto free_priv;
 
-	err = sysfs_create_group(&priv->dev.kobj, &iscsi_transport_group);
+	err = sysfs_create_group(&priv->cdev.kobj, &iscsi_transport_group);
 	if (err)
-		goto unregister_dev;
+		goto unregister_cdev;
 
 	/* host parameters */
 	priv->t.host_attrs.ac.attrs = &priv->host_attrs[0];
@@ -2019,8 +2024,8 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	printk(KERN_NOTICE "iscsi: registered transport (%s)\n", tt->name);
 	return &priv->t;
 
-unregister_dev:
-	device_unregister(&priv->dev);
+unregister_cdev:
+	class_device_unregister(&priv->cdev);
 	return NULL;
 free_priv:
 	kfree(priv);
@@ -2048,8 +2053,8 @@ int iscsi_unregister_transport(struct iscsi_transport *tt)
 	transport_container_unregister(&priv->session_cont);
 	transport_container_unregister(&priv->t.host_attrs);
 
-	sysfs_remove_group(&priv->dev.kobj, &iscsi_transport_group);
-	device_unregister(&priv->dev);
+	sysfs_remove_group(&priv->cdev.kobj, &iscsi_transport_group);
+	class_device_unregister(&priv->cdev);
 	mutex_unlock(&rx_queue_mutex);
 
 	return 0;
diff --git a/scsi_transport_iscsi.h b/scsi_transport_iscsi.h
index ef4b697..a633ee0 100644
--- a/scsi_transport_iscsi.h
+++ b/scsi_transport_iscsi.h
@@ -27,6 +27,7 @@
 #include <linux/list.h>
 #include <linux/mutex.h>
 #include "iscsi_if.h"
+#include "open_iscsi_compat.h"
 
 struct scsi_transport_template;
 struct iscsi_transport;
@@ -219,7 +220,7 @@ extern void iscsi_host_for_each_session(struct Scsi_Host *shost,
 
 struct iscsi_endpoint {
 	void *dd_data;			/* LLD private data */
-	struct device dev;
+	struct class_device dev;
 	uint64_t id;
 };
 
-- 
1.6.6.1

